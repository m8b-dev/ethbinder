<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ether Binder: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ether Binder
   </div>
   <div id="projectbrief">Set of utilities for interacting with Ethereum and it&#39;s smart contracts with PHP, with generating ABI bindings and Ethereum-related types</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2utils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Utilities</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md55"></a> Ether Binder comes with some utilities:</p>
<h1><a class="anchor" id="autotoc_md56"></a>
WeiFormatter</h1>
<p>Helper to parse Ether units from and to human format. It allows some common human notations, can survive white spaces, it supports <code>,</code> and <code>.</code>, and even works with <code>10,000.00</code> human notation. It can work with floats too. From human static function returns <code>OOGmp</code> of parsed value and from wei returns string.</p>
<p><code>WeiFormatter::fromHuman("10,123.45)&lt;/tt&gt; will return &lt;tt&gt;OOGmp&lt;/tt&gt; with value of &lt;tt&gt;10123.45 * 10**18&lt;/tt&gt;.

It also accepts OOGmp to allow converting with common logic across Ethereum notation formats, like GWEI to ETHER.

To leverage this in such way, there is special enum that defines supported formats - &lt;tt&gt;EtherFormats&lt;/tt&gt;. This parameter is
last in both functions, and always refers to "human" side of input or output.

&lt;tt&gt;fromWei&lt;/tt&gt; requires second parameter which is how many decimal places should be taken.

Example usage:

@icode{php} 
// convert 12 gwei to eth
$twelveGwei = \M8B\EtherBinder\Utils\WeiFormatter::fromHuman(12, \M8B\EtherBinder\Utils\EtherFormats::GWEI);
$twelveGweiInEther = \M8B\EtherBinder\Utils\WeiFormatter::fromWei($twelveGwei, 10);
echo $twelveGweiInEther; // 0.0000000120

$valueEth = \M8B\EtherBinder\Utils\WeiFormatter::fromHuman("10");
echo $valueEth-&gt;toString(); // 10000000000000000000
@endicode 

@section autotoc_md57 OOGmp

Object wrapper for php's standard &lt;tt&gt;gmp&lt;/tt&gt; library. This object is used practically everywhere in library where big numbers
come into play. The constructor can take strings, integers or GMP itself. In case of creating with string, you SHOULD pass
hex string with &lt;tt&gt;0x&lt;/tt&gt; prefix OR supply second parameter, base as 16. If that's not done, the hex string may look like
"normal" decimal string, and the OOGmp will do best-effort to guess, which will result in parsing as decimal.

Consider example:
@icode{php} 
print_r([
    "0x20" =&gt; (new \M8B\EtherBinder\Utils\OOGmp("0x20"))-&gt;toString() 
    "20" =&gt; (new \M8B\EtherBinder\Utils\OOGmp("20"))-&gt;toString()
    "20,16" =&gt; (new \M8B\EtherBinder\Utils\OOGmp("20", 16))-&gt;toString()
]);
@endicode 
will return:
@icode 
Array
(
    [0x20] =&gt; 32
    [20] =&gt; 20
    [20,16] =&gt; 32
)
@endicode 

Alternatively, instead of constructor you may use &lt;tt&gt;::wrap()&lt;/tt&gt; to wrap existing GMP. Note that you can just do that with
constructor.

@subsection autotoc_md58 Arithmetic Functions:

The class provides basic arithmetic operations like addition (&lt;tt&gt;add&lt;/tt&gt;), subtraction (&lt;tt&gt;sub&lt;/tt&gt;), multiplication (&lt;tt&gt;mul&lt;/tt&gt;), and division (&lt;tt&gt;div&lt;/tt&gt;).
These methods support automatic type normalization, allowing you to pass in &lt;tt&gt;OOGmp|int|GMP&lt;/tt&gt; as arguments.
None of these functions modify state of object it's called for, and instead return new &lt;tt&gt;OOGmp&lt;/tt&gt; instance. Argument is
always "right" side of equation, while object it's called on is always "left" side of equation. It's OK, and even
encouraged to chain operations, and even when needed finish it off with some form of encoding:

@icode{php} 
$value = new \M8B\EtherBinder\Utils\OOGmp(10);
echo $value
    -&gt;mul(10) // 100
    -&gt;add(20) // 120
    -&gt;div(6)  // 20
    -&gt;mod(3)  // 3
    -&gt;toString(); // "3"
@endicode 

@subsection autotoc_md59 Comparison Functions:

Standard comparison operations are included, such as &lt;tt&gt;eq&lt;/tt&gt; (equals), &lt;tt&gt;lt&lt;/tt&gt; (less than), &lt;tt&gt;gt&lt;/tt&gt; (greater than), etc.
Aliases are also available, like &lt;tt&gt;eq&lt;/tt&gt; - &lt;tt&gt;equal&lt;/tt&gt;. These functions also support automatic type normalization, just like
arithmetic functions.

@subsection autotoc_md60 Getting data

OOGmp allows you to fetch internal data in few ways.

@subsubsection autotoc_md61 raw

You can get raw underlying gmp
@icode{php} 
$value = new \M8B\EtherBinder\Utils\OOGmp(10);
$value-&gt;raw(); // returns \GMP
@endicode 

@subsubsection autotoc_md62 toString

You can get string representation (also has &lt;tt&gt;__toString&lt;/tt&gt;):
@icode{php} 
$value = new \M8B\EtherBinder\Utils\OOGmp(10);
$string = $value-&gt;toString();
@endicode 
This method has couple of options:
@icode 
0: bool $hex = false
    if true, returns hexadecimal string, instead of decimal string
1: bool $no0xHex = false
    param is ignored if $hex is false, if set to true, the hex string will be without 0x prefix
2: ?int lPad0 = null
    if null, logic is ignored. Integer desired length of string, which will be achieved by padding from left with zeroes.
    Note that if resulting string without padding is longer than the param, the string will not be truncated, but will be
    returned as if the param was null.
@endicode 

For negative numbers, you get two's complement format, like -256 = "0xFF00".

@subsubsection autotoc_md63 toBin

Encodes the integer in binary format. Most likely you want to supply optional parameter to get known length of that int.

@icode{php} 
$lPad0 = 32;
$value = new \M8B\EtherBinder\Utils\OOGmp(10);
$binary = $value-&gt;toBin($lPad0);
@endicode 

Left Pad 0 takes amount of BYTES of desired length, so hexadecimal representation of this binary blob will be 64 
characters long (without 0x). It is optional parameter.
For negative numbers, you get two's complement format, just like with hex string.


@section autotoc_md64 Functions

is class that is host for misc utility functions.

@subsection autotoc_md65 assert hex size

&lt;tt&gt;mustHexLen&lt;/tt&gt; validates if string is hexadecimal of given length, and throws InvalidHexLengthException if length is wrong,
or InvalidHexException if the string isn't valid hex. Bear in mind, that length does NOT include 0x prefix, which is
optional
@icode{php} 
$hex = "0f00ba12"
$len = 8;
\M8B\EtherBinder\Utils\Functions::mustHexLen($hex, $len)
@endicode 

@subsection autotoc_md66 left pad hex

&lt;tt&gt;lPadHex&lt;/tt&gt; Left-pads a hex string to a specific length. It supports multiplies of padding, for example if you need to
pad unknown length string to be multiples of 2 for proper byte representation. That's what last param is enabling.
First param is hex to be padded, and second param is the pad length 
@icode{php} 
\M8B\EtherBinder\Utils\Functions::lPadHex("f00", 2, true); // 0f00
@endicode 

@subsection autotoc_md67 int &lt;-&gt; hex string

&lt;tt&gt;int2hex&lt;/tt&gt; is basically proxy function to &lt;tt&gt;dechex&lt;/tt&gt; but with "0x" support, and &lt;tt&gt;hex2int&lt;/tt&gt; is opposite, but using OOGmp for
exception support like exceeding max int size and 0x prefix tolerance.
@icode{php} 
\M8B\EtherBinder\Utils\Functions::hex2int("0xff"); // 255 \M8B\EtherBinder\Utils\Functions::int2hex(255); // 0xff </code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md68"></a>
next block fee</h2>
<p><code></code></p>
<p><code><code>getNextBlockBaseFee</code> deterministically calculates next block's base fee. If you want to emulate the behaviour, to account for example next N blocks worst case scenario, these values of block you will need to fill in: </p><div class="fragment"><div class="line">$block = new \M8B\EtherBinder\Common\Block();</div>
<div class="line">$block-&gt;baseFeePerGas = $previousFunctionCallOutput;</div>
<div class="line">$block-&gt;number = $previousBlock-&gt;number + 1;</div>
<div class="line">$block-&gt;gasLimit = $previousBlock-&gt;gasLimit;</div>
<div class="line">$block-&gt;gasUsed = $previousBlock-&gt;gasLimit;</div>
</div><!-- fragment --><p></code></p>
<p><code>The second parameter is internal type EIP1559Config, which as of now, simply defines some constants and concrete chains only inform about EIP-1559 activation block. If your chain isn't on the static functions list, just use <code>sepolia</code>, if you are sure that you always call on EIP-1559 enabled chain.</code></p>
<p><code>Usage: </p><div class="fragment"><div class="line">$block = $rpc-&gt;ethGetBlockByNumber();</div>
<div class="line">$nextBlockFee = \M8B\EtherBinder\Utils\Functions::getNextBlockBaseFee($block, \M8B\EtherBinder\Misc\EIP1559Config::mainnet());</div>
</div><!-- fragment --><p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md69"></a>
Blocking wait for transaction</h2>
<p><code></code></p>
<p><code>This function will wait and block until the transaction is confirmed via repetitively checking receipt and catching errors until timeout runs out. It accepts either Transaction or Hash objects, and will wait up to 3rd param of seconds and query rpc (2nd param) every 4th param of milliseconds.</code></p>
<p><code></p><div class="fragment"><div class="line">$rpc-&gt;ethSendRawTransaction($transaction);</div>
<div class="line">$receipt = \M8B\EtherBinder\Utils\Functions::waitForTxReceipt(</div>
<div class="line">    $transaction, $rpc, 300 <span class="comment">/*5 minutes*/</span>, 1000 <span class="comment">/* check every second*/</span>);</div>
</div><!-- fragment --><p> </code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
