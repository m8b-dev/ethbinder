<?php

namespace M8B\EtherBinder\Contract;

use M8B\EtherBinder\Common\Address;
use M8B\EtherBinder\Common\Hash;
use M8B\EtherBinder\Common\SolidityFunction;
use M8B\EtherBinder\Common\SolidityFunctionSignature;
use M8B\EtherBinder\Common\Transaction;
use M8B\EtherBinder\Exceptions\NotSupportedException;
use M8B\EtherBinder\Utils\OOGmp;
use PhpParser\BuilderFactory;
use PhpParser\Node\Expr\Assign;
use PhpParser\Node\Stmt\Return_;
use PhpParser\PrettyPrinter\Standard;

class ABIGen
{
	protected array $abiFunctions;
	protected array $abiEvents;
	protected array $abiConstructor;

	public function __construct(array $abi, protected ?string $compiledBlob = null)
	{
		$this->abiFunctions   = [];
		$this->abiEvents      = [];
		$this->abiConstructor = [];

		foreach($abi AS $abiItem)
		{
			$this->{match ($abiItem["type"]){
				"event"       => "abiEvents",
				"constructor" => "abiConstructor",
				"function"    => "abiFunctions",
				default       => throw new \InvalidArgumentException("abi element type '" . $abiItem["type"] . "' not recognized")
			}}[] = $abiItem;
		}
	}

	public function gen(string $fullyQualifiedClassName): array
	{
		if(empty($fullyQualifiedClassName))
			throw new \InvalidArgumentException();
		// split fqcn to namespace and class
		$hasNamespace = str_contains(substr($fullyQualifiedClassName, 1), "\\");
		if(!$hasNamespace) {
			$className = ltrim($fullyQualifiedClassName, "\\"); // valid FQCN is "FooClass" and "\FooClass"
			$namespace = "\\";
			trigger_error("generating into global namespace, this is most likely unwanted", E_USER_WARNING);
		} else {
			if($fullyQualifiedClassName[0] !== "\\")
				// prohibit namespace\class as someone might mistake it for \current\namespace\class etc.
				throw new \InvalidArgumentException("first character of FQCN must be '\\', at least in this implementation");
			$exploded = explode("\\", $fullyQualifiedClassName);
			$className = array_pop($exploded);
			$namespace = implode("\\", $exploded);
		}

		$bld = new BuilderFactory();

		$class = $bld->class($className)
			->extend(AbstractContract::class)
			->addStmt($bld->method("abi")
				->makePublic()
				->makeStatic()
				->setReturnType("string")
				->addStmt(
					new Return_($bld->val(json_encode(array_merge($this->abiFunctions, $this->abiConstructor, $this->abiEvents))))
				)
			)
			->addStmt($bld->method("bytecode")
				->makePublic()
				->makeStatic()
				->setReturnType("?string")
				->addStmt(
					new Return_($bld->val($this->compiledBlob))
				)
			);

		$processedNames = [];

		foreach($this->abiFunctions AS list(
				"name" => $fname,
				"stateMutability" => $smut,
				"outputs" => $outs,
				"inputs" => $prms)
		) {
			if(in_array($fname, $processedNames)) {
				trigger_error("function $fname appears in abi file more than once. Some compilers produce such output. Skipping next occurrence.", E_USER_WARNING);
				continue;
			}
			$processedNames[] = $fname;

			$abstractCall = match($smut) {
				"pure", "view" => "mkCall",
				"nonpayable"   => "mkTxn",
				"payable"      => "mkPayableTxn",
				default => throw new NotSupportedException("state mutability '$smut' is not supported")
			};
			list("params"    => $paramsBuilt,
				"names"      => $paramNames,
				"validators" => $validators,
				"signature"  => $fnSignature) = $this->buildMethodParams($fname, $prms, $bld);

			if($abstractCall === "mkCall") {
				$retType = $this->getPhpTypingFromOutputs($outs);
			} else {
				$retType = Transaction::class;
			}

			$paramRefs = [$fnSignature];
			$idx = 1;
			if($smut == "payable") {
				array_unshift($paramsBuilt, $bld->param("transactionValue")->setType(OOGmp::class));
				$paramRefs[] = $bld->var("transactionValue");
				$idx++;
			}
			foreach($paramNames AS $paramName)
				$paramRefs[$idx][] = $bld->var($paramName);

			$class->addStmt($bld->method($fname)
				->makePublic()
				->addParams($paramsBuilt)
				->addStmts($validators)
				->setReturnType($retType)
				->addStmt(
					new Return_($bld->methodCall($bld->var("this"), $abstractCall, $paramRefs))
				)
			);
		}

		$class->setDocComment("/// Autogenerated source code");
		if($hasNamespace) {
			$nodes = [
				$bld->namespace($namespace)->addStmt($class)->getNode()];
		} else {
			$nodes = [$class->getNode()];
		}
		return [
			"contract" => (new Standard())->prettyPrintFile($nodes),
			"events" => $this->generateEventClasses($namespace, $className)
		];
	}

	protected function buildMethodParams(string $fnName, array $inputs, BuilderFactory $bld)
	{
		// see https://docs.soliditylang.org/en/latest/abi-spec.html
		$signature = $fnName."(";
		$validators = [];
		$names = [];
		$params = [];
		$firstIt = true;

		foreach($inputs AS list("name" => $name, "type" => $type)) {
			$signature .= $firstIt ? $type:",$type";
			if($firstIt)
				$firstIt = false;
			$param = $bld->param($name);
			if($type === "uint" || $type == "int") {
				$param->setType(OOGmp::class);
			} elseif(str_starts_with($type, "uint") || str_starts_with($type, "int")) {
				// remove characters, to get bits count
				$bitsCount = (int)ltrim($type, "uint");
				$arr = false;
				if(str_contains($type, "[")) {
					$param->setType("array");
					$arr = true;
				} elseif($bitsCount <= 32) {
					$param->setType("int");
				} else {
					$param->setType(OOGmp::class);
				}
				$validators [] = new Assign(
					$bld->var($name),
					$bld->methodCall($bld->var("this"), $arr ? "expectIntArrOfSize" : "expectIntOfSize", [
						$bld->val($type[0] === "u"),
						$bld->var($name),
						$bld->val($bitsCount)])
				);
			} elseif($type == "address") {
				$param->setType(Address::class);
			} elseif($type == "bool" || $type == "boolean") {
				$param->setType("bool");
			} elseif(str_starts_with($type, "fixed") || str_starts_with($type, "ufixed")) {
				// see https://docs.soliditylang.org/en/latest/abi-spec.html specific quite:
				// Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.
				//
				// which basically means they are allocated, but cannot be written or read - rendering type useless.
				throw new NotSupportedException("fixed types are not supported in abigen nor in solidity");
			} elseif(str_contains($type, "[")) {
				$param->setType("array");
			} elseif($type == "function") {
				$param->setType(SolidityFunctionSignature::class);
			} elseif($type == "bytes32") {
				$param->setType(Hash::class);
			} elseif(str_starts_with($type, "bytes")) {
				$size = (int)ltrim($type, "bytes");
				$validators [] = new Assign(
					$bld->var($name),
					$bld->methodCall($bld->var("this"), "expectBinarySizeNormalizeString", [
						$bld->var($name),
						$bld->val((int)$size)])
				);
				$param->setType("string");
			} else {
				throw new NotSupportedException("type $type was not recognized abi type");
			}
			$params[] = $param;
			$names[] = $name;
		}
		return ["params" => $params, "names" => $names, "validators" => $validators, "signature" => $signature . ")"];
	}

	protected function getPhpTypingFromOutputs(array $outputs)
	{
		if(empty($outputs))
			return "void";
		if(count($outputs) > 1)
			return "array";
		$outputT = $outputs[0]["type"];
		if(str_contains($outputT, "[") && $outputT !== "byte[]")
			return "array";
		if(str_starts_with($outputT, "uint") || str_starts_with($outputT, "int"))
			return OOGmp::class;
		if(str_starts_with($outputT, "bytes") && $outputT !== "bytes32")
			return "string";

		return match($outputT) {
			"bytes32"          => Hash::class,
			"byte[]", "string" => "string",
			"function"         => SolidityFunction::class,
			"bool", "boolean"  => "bool",
			"address"          => Address::class,
			default            => throw new NotSupportedException("output type $outputT is not supported")
		};
	}

	protected function generateEventClasses(string $namespace, string $classPrefix): array
	{return [];/*fixme*/}
}