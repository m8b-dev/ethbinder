<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ether Binder: Generating bindings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ether Binder
   </div>
   <div id="projectbrief">Set of utilities for interacting with Ethereum and it&#39;s smart contracts with PHP, with generating ABI bindings and Ethereum-related types</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2contracts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Generating bindings</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md10"></a> One of main features of EtherBinder is bindings (hence the name). It is alternative of <a href="https://geth.ethereum.org/docs/tools/abigen">geth's abigen</a> for PHP.</p>
<p>In essence, it creates typed classes that allow you to interact with smart contract on EVM chain. The binding handles for you underlying complexity, mostly abi en/de-coding.</p>
<p>To create binding you need abi json file. If you want to be able to deploy contract, you also need compiled byte code in hex format. The combined format is not supported at the second.</p>
<p>Following examples will use this example ERC20 implementation: </p><div class="fragment"><div class="line">// SPDX-License-Identifier: MIT</div>
<div class="line">pragma solidity ^0.8.0;</div>
<div class="line"> </div>
<div class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</div>
<div class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</div>
<div class="line"> </div>
<div class="line">contract Token is ERC20, Ownable {</div>
<div class="line">    struct Test {</div>
<div class="line">        uint256 foo;</div>
<div class="line">        uint256 bar;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    constructor(string memory name, string memory symbol) ERC20(name, symbol) {</div>
<div class="line">        _mint(msg.sender, 8_000_000 * 10 ** 18);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    function returnsTuple() external pure returns(Test memory) {</div>
<div class="line">        Test memory t;</div>
<div class="line">        t.foo = 123;</div>
<div class="line">        t.bar = 456;</div>
<div class="line">        return t;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    function returnsArray() external pure returns(Test[] memory) {</div>
<div class="line">        Test[] memory t;</div>
<div class="line">        t[0] = Test(123,456);</div>
<div class="line">        t[1] = Test(78,90);</div>
<div class="line">        return t;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    function returnsMultiple() external pure returns(Test memory, Test memory) {</div>
<div class="line">        Test memory t;</div>
<div class="line">        t.foo = 123;</div>
<div class="line">        t.bar = 456;</div>
<div class="line">        Test memory t2;</div>
<div class="line">        t2.foo = 78;</div>
<div class="line">        t2.bar = 90;</div>
<div class="line">        return (t, t2);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Assuming that you have built above contract and stored it's abi in <code>./erc20.abi.json</code> and bytecode in <code>./erc20.bin.hex</code> (note: bytecode must be in hex format, not binary blob); and assuming that you have ./src as your project root and want your binding to reside in <code>\Contracts</code> namespace, you can call: </p><div class="fragment"><div class="line">./vendor/bin/abigen.php --abi erc20.abi.json --bin erc20.bin.hex --fqcn \\Contracts\\ERC20 --out ./src/contracts</div>
</div><!-- fragment --><p>The used parameters are:</p><ul>
<li><code>--abi</code> - path to abi json file</li>
<li><code>--bin</code> - optional path to bytecode file</li>
<li><code>--fqcn</code> - fully qualified class name of root class of the binding. Events and tuples will derive their names from this name too. If it points to global namespace, warning will be emitted. Also bear in mind that shel will treat single <code>\</code> as escape character, so to pass namespace, you need to escape <code>\</code> with another <code>\</code></li>
<li><code>--out</code> - path to directory (if it doesn't exist, it will be created). Any file that will be generated will be overwritten, but directory itself will not be cleared.</li>
</ul>
<p>Bear in mind that you need to take into account your autoloader setup when writing namespace and directory.</p>
<p>This should result in bindings being generated into <code>./src/contracts</code> with main class <code>./src/contracts/ERC20.php</code></p>
<h1><a class="anchor" id="autotoc_md11"></a>
Events limitation</h1>
<p>Currently, event allows parsing event data into appropriate object (to <code>Event</code> classes). There is a rare case of having events that emit indexed dynamic data such as strings, arrays or tuples. Solidity in such case returns keccak256 hash of such data, not the data itself, making the data itself unrecoverable. If the ABIGen stumbles upon such event, while generating bindings, it will throw NotSupportedException. Such events are not supported. In pinch, it's OK to remove the event from ABI JSON manually, but of course, such events will not be parsed.</p>
<p>If this happens you get exception with explainer and exactly which event and it's type causes the problem, so you can adjust ABI or contract.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Usage notes</h1>
<p>Usage code samples will assume you have defined private key and RPC </p><div class="fragment"><div class="line">$key = \M8B\EtherBinder\Crypto\Key::fromHex(<span class="stringliteral">&quot;0x...&quot;</span>);</div>
<div class="line">$rpc = new \M8B\EtherBinder\RPC\HttpRPC(<span class="stringliteral">&quot;https://...&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Deploying contract</h1>
<p>To deploy contract call static function <code>deployNewCLASS_NAME</code>. First 2 parameters are always <code>AbstractRpc</code> and private <code>Key</code>. Rest of parameters depend on given contract as these are input for it.</p>
<div class="fragment"><div class="line">$transaction = \Contracts\ERC20::deployNewERC20($rpc, $key, <span class="stringliteral">&quot;Ether Binder Token&quot;</span>, <span class="stringliteral">&quot;TEST&quot;</span>);</div>
<div class="line">echo <span class="stringliteral">&quot;Deployed ERC 20 token to &quot;</span> . $transaction-&gt;deployAddress()-&gt;checksummed() . PHP_EOL;</div>
<div class="line">echo <span class="stringliteral">&quot;with transaction hash &quot;</span> . $transaction-&gt;hash()-&gt;toHex() . PHP_EOL;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
Instantiating contract binding</h1>
<p>In most basic form, the instantiating requires only RPC and contract address: </p><div class="fragment"><div class="line">$address = \M8B\EtherBinder\Common\Address::fromHex(ERC20_ADDRESS);</div>
<div class="line">$token   = new \Contracts\ERC20($rpc, $address);</div>
</div><!-- fragment --><p>You can also supply private key and/or fallback address while instantiating. If you supply key, it's address will be used ass fallback, regardless if you set fallback address, or not. Supplying private keys allows binding to sign and send transactions, while fallback address is used for estimations and calls (from field). Not supplying any of these will set this field to null address (0x000...). Depending on contract logic, this may produce invalid estimations or throw exceptions that wouldn't be thrown otherwise (for example reverting due to "insufficient balance")</p>
<p>To supply private key: </p><div class="fragment"><div class="line">$address = \M8B\EtherBinder\Common\Address::fromHex(ERC20_ADDRESS);</div>
<div class="line">$token   = new \Contracts\ERC20($rpc, $address, $key);</div>
</div><!-- fragment --><p>Or when you already have contract instantiated: </p><div class="fragment"><div class="line">$token-&gt;loadPrivK($key);</div>
</div><!-- fragment --><p>To remove private key: </p><div class="fragment"><div class="line">$token-&gt;unloadPrivK();</div>
</div><!-- fragment --><p>To supply fallback address, and get unsigned transactions: </p><div class="fragment"><div class="line">$address = \M8B\EtherBinder\Common\Address::fromHex(<span class="stringliteral">&quot;0x....&quot;</span>);</div>
<div class="line">$token   = new \Contracts\ERC20($rpc, $address, <span class="keyword">null</span>, $key-&gt;toAddress());</div>
</div><!-- fragment --><p>To add fallback on already instantiated contract: </p><div class="fragment"><div class="line">$token-&gt;unsetFallbackFrom();</div>
</div><!-- fragment --><p>To remove fallback on already instantiated contract: </p><div class="fragment"><div class="line">$token-&gt;setFallbackFrom($key-&gt;toAddress());</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Using read functions on contract</h1>
<p>To read contract, you just need to call function of bound contract object with same name, and pass same params as in solidity. </p><div class="fragment"><div class="line">print_r([</div>
<div class="line">    <span class="stringliteral">&quot;name&quot;</span>     =&gt; $token-&gt;name(),</div>
<div class="line">    <span class="stringliteral">&quot;symbol&quot;</span>   =&gt; $token-&gt;symbol(),</div>
<div class="line">    <span class="stringliteral">&quot;decimals&quot;</span> =&gt; $token-&gt;decimals(),</div>
<div class="line">    <span class="stringliteral">&quot;balance&quot;</span>  =&gt; $token-&gt;balanceOf($key-&gt;toAddress())</div>
<div class="line">]);</div>
</div><!-- fragment --><p>Tuples are supported and typed </p><div class="fragment"><div class="line">$tuple = $token-&gt;returnsTuple();</div>
<div class="line">var_dump($tuple-&gt;getFoo()-&gt;eqal(123)) <span class="comment">// true</span></div>
</div><!-- fragment --><p>Some functions return multiple variables. To show this, the example solidity code has <code>returnsMultiple</code> test function. </p><div class="fragment"><div class="line">list($tupleA, $tupleB) = $token-&gt;returnsMultiple();</div>
<div class="line">var_dump($tupleA::class == \Contracts\ERC20TupleTest::class); <span class="comment">// true</span></div>
<div class="line">var_dump($tupleB::class == \Contracts\ERC20TupleTest::class); <span class="comment">// true</span></div>
<div class="line">var_dump($tupleA-&gt;getFoo()-&gt;eqal(123)) <span class="comment">// true</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Using write functions</h1>
<p>Write functions work similarly to read functions, but instead return transactions in different states. The state depends on binding state, and you can read more about it in instantiation section. Transaction kind is dynamically determined based on underlying chain (Legacy or London).</p>
<div class="fragment"><div class="line">$recipient = \M8B\EtherBinder\Common\Address::fromHex(<span class="stringliteral">&quot;0x....&quot;</span>);</div>
<div class="line">$transaction = $token-&gt;transfer($recipient, \M8B\EtherBinder\Utils\WeiFormatter::fromHuman(<span class="stringliteral">&quot;100&quot;</span>));</div>
</div><!-- fragment --><p>If function is payable, first param accepts value wrapped in OOGmp (Ether Binder's big number object), and function params start from second param.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Reading events</h1>
<p>Ether Binder has 3 ways to parse events.</p>
<p>One way is to parse a specific event from Log </p><div class="fragment"><div class="line">$hash = \M8B\EtherBinder\Common\Hash::fromHex(<span class="stringliteral">&quot;0x....&quot;</span>);</div>
<div class="line">$receipt = $rpc-&gt;ethGetTransactionReceipt($hash);</div>
<div class="line">$event = \Contracts\ERC20EventTransfer::parseEventFromLog($receipt-&gt;logs[0]);</div>
<div class="line">print_r([</div>
<div class="line">    <span class="stringliteral">&quot;from&quot;</span> =&gt; $event-&gt;getFrom()-&gt;checksummed(),</div>
<div class="line">    <span class="stringliteral">&quot;to&quot;</span> =&gt; $event-&gt;getTo()-&gt;checksummed(),</div>
<div class="line">    <span class="stringliteral">&quot;value&quot;</span> =&gt; $event-&gt;getValue()-&gt;toString()</div>
<div class="line">]);</div>
</div><!-- fragment --><p>Second way is to parse all events from Receipt </p><div class="fragment"><div class="line">$hash = \M8B\EtherBinder\Common\Hash::fromHex(<span class="stringliteral">&quot;0x....&quot;</span>);</div>
<div class="line">$receipt = $rpc-&gt;ethGetTransactionReceipt($hash);</div>
<div class="line">$events = \Contracts\ERC20::getEventsFromReceipt($receipt-&gt;logs);</div>
<div class="line">var_dump($events);</div>
</div><!-- fragment --><p>Third way is to use filter binding. <b>NOTE:</b> After getting constructed, it does not install filter on RPC, and therefore the events listening didn't start yet. At this point you can additionally configure the object with <code>setFromBlock</code> and <code>setToBlock</code> methods to set filter's start and end. To install filter either start fetching with <code>parseFetchNext</code> or call <code>installFilter</code>. Note that after doing so, the <code>setFromBlock</code> and <code>setToBlock</code> methods will throw exceptions. To set new from / to values, instantiate new filter.</p>
<p>The binding for parameters accepts rpc and contract address, and then the indexed params from event. Event dependent params can be null (to accept any event) or array (to set up OR filter for this variable). If array is provided, all items must be of same type as single item typing, otherwise an exception will be thrown.</p>
<p><code>fetchNext()</code> will return next known event, or null if no more events were found</p>
<div class="fragment"><div class="line">$recipient = \M8B\EtherBinder\Common\Address::fromHex(<span class="stringliteral">&quot;0x....&quot;</span>);</div>
<div class="line">$filter = new \M8B\EtherBinder\Test\ERC20FilterTransfer($rpc, $address, $key-&gt;toAddress(), <span class="keyword">null</span>);</div>
<div class="line">$filter-&gt;installFilter();</div>
<div class="line">$token-&gt;transfer($recipient, \M8B\EtherBinder\Utils\WeiFormatter::fromHuman(1));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(($transfer = $filter-&gt;fetchNext()) !== <span class="keyword">null</span>) {</div>
<div class="line">    echo <span class="stringliteral">&quot;got event &quot;</span>.$transfer-&gt;getTo()-&gt;checksummed().<span class="stringliteral">&quot; =&gt; &quot;</span>.$transfer-&gt;getFrom()</div>
<div class="line">        .<span class="stringliteral">&quot;, val=&quot;</span>.WeiFormatter::fromWei($transfer-&gt;getValue()-&gt;toString(), 5). PHP_EOL;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md18"></a>
Influencing gas prices of binding's transactions</h1>
<p>Binding has static variable <code>AbstractContract::$transactionFeesPercentageBump</code>.</p>
<p>It is flat percentage bump, defaults to 0. For legacy transactions it influences gas price, and for post-London transactions it influences both base fee cap and tip fee. If set to for example 10, it means the gas price will be 110% of what it would be at default.</p>
<p>Calculation is simple: </p><div class="fragment"><div class="line">// pseudocode</div>
<div class="line">estimatedFee = estimator()</div>
<div class="line">estimatedFee = (100 + transactionFeesPercentageBump) / 100</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
